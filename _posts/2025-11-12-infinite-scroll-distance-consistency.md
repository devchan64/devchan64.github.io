---
layout: post
title: "무한 스크롤과 스크롤 거리의 정합에 대한 아이데이션"
date: 2025-11-12
categories: [frontend, ux, virtualization]
tags: [infinite-scroll, pagination, ux, virtual-list, data-consistency]
---

# 무한 스크롤과 스크롤 거리의 정합에 대한 아이데이션

## 🧭 개요

무한 스크롤은 사용자에게 끊김 없는 탐색 경험을 제공합니다.  
하지만 스크롤의 물리적 거리와 실제 데이터의 위치 사이에는 미묘한 불일치가 존재합니다.  
이 글은 무한 스크롤 환경에서 **스크롤 거리와 데이터 정합을 유지하는 방법**을 탐색하며,  
“사용자는 자연스럽게, 시스템은 일관되게” 작동하도록 만들기 위한 개인적인 정리를 담고 있습니다.

---

## 1. 무한 스크롤이 어렵게 만드는 정합의 문제

무한 스크롤은 비동기 로딩과 동적 높이 변화라는 두 가지 불확실성을 전제로 합니다.  
각 아이템의 렌더링 높이가 다르거나, 이미지·광고·콘텐츠가 늦게 로드될 경우  
스크롤 위치는 데이터 인덱스와 직접적으로 대응하지 않습니다.  

이 과정에서 다음과 같은 현상이 자주 관찰됩니다.

- 스크롤 위치 복원 실패  
- 로딩 중 높이 점프(jump)  
- 아직 불러오지 않은 데이터로의 점프 처리 곤란  
- 누락된 데이터나 중복된 데이터가 섞인 불연속 구간  

이 현상들은 단순한 뷰포트 제어나 가상 리스트만으로는 해결되지 않으며,  
결국 “데이터와 위치의 일관성”이라는 근본적 주제와 맞닿아 있습니다.

---

## 2. 서버와 클라이언트가 함께 고려되어야 하는 구조

정합은 어느 한쪽의 노력으로 완성되기 어렵습니다.  

**서버 측에서는**  
- 정렬 기준이 명확하고 안정적으로 유지될 필요가 있습니다. (예: createdAt + id 조합)  
- 커서 기반 페이징으로 멱등성과 순서를 보장해야 합니다.  
- 동일 시점 기준의 연속 요청을 가능하게 하는 snapshotId가 도움이 됩니다.  
- 렌더링 힌트(예상 높이 등)를 제공하면 클라이언트가 거리 계산에 활용할 수 있습니다.  

**클라이언트 측에서는**  
- 스크롤 위치를 데이터 앵커(anchor)로 관리합니다.  
- 안전영역(safe window)을 설정하여 로드·언로드 범위를 통제합니다.  
- 데이터, 커서, 높이 정보를 하나의 스냅샷(snapshot)으로 묶어 일관된 상태를 유지합니다.  

이처럼 서버와 클라이언트가 서로의 역할을 인식할 때  
스크롤 거리와 데이터 정합의 균형이 조금 더 명확히 드러나는 것 같습니다.

---

## 3. 스크롤 정합을 위한 스냅샷 모델

정합을 생각할 때마다 **“현재까지 로드된 데이터의 상태를 하나의 좌표계로 유지할 수 있을까”**라는 질문으로 돌아옵니다.  
그래서 스냅샷(snapshot)이라는 구조를 상정해 보았습니다.  
스냅샷은 단순한 캐시가 아니라, **“데이터와 물리적 위치를 연결하는 논리적 좌표계”**로 이해되고 있습니다.

### 스냅샷의 구성 요소

스냅샷은 다음과 같은 정보를 포함합니다.

- `items`: 로드된 데이터 배열 (순서 보장)
- `cursors`: 이전·다음 페이지를 요청하기 위한 커서 정보
- `estimatedHeights`: 각 아이템의 예상 높이  
- `measuredHeights`: 실제 렌더링 이후 측정된 높이
- `cumulativeHeights`: 0~i번째 아이템까지의 누적 높이 합
- `totalScrollableHeight`: 전체 스크롤 가능한 높이
- `anchorId`, `anchorOffset`: 화면 중심 또는 최상단 기준의 위치 앵커
- `meta`: 필터, 정렬, 버전, 타임스탬프 등 유효성을 판단하는 메타데이터

### 스냅샷의 작동 과정

1. **초기 로드 시점**  
   첫 페이지를 받아오면, 각 아이템에 대해 예상 높이를 설정하고 누적 높이를 계산합니다.  
   이 시점의 전체 스크롤 높이는 추정치에 가깝습니다.

2. **렌더링 및 보정 단계**  
   렌더링 후 실제 높이를 측정하면 `measuredHeights`가 `estimatedHeights`를 갱신합니다.  
   이후의 아이템에 대해서는 누적 높이를 재계산하여 오차를 점진적으로 줄여갑니다.  
   사용자는 이 변화를 거의 인식하지 못한 채 자연스러운 흐름을 경험하게 됩니다.

3. **스크롤 이동 중 관리**  
   스크롤 중에는 `cumulativeHeights`를 이용해  
   scrollTop에 대응하는 아이템 인덱스를 빠르게 탐색할 수 있습니다.  
   이는 O(log n)의 비용으로 계산 가능하며,  
   무한 스크롤의 성능적 안정성 확보에 유용한 방식으로 느껴집니다.

4. **앵커 기반 복원**  
   다른 화면으로 이동했다가 돌아올 경우  
   `anchorId`와 `anchorOffset`으로 이전 위치를 복원합니다.  
   데이터 순서가 유지되는 한, 복원은 시각적으로 안정적으로 작동합니다.

### 스냅샷의 의의

스냅샷은 단순한 로컬 캐시가 아니라  
“어떤 시점의 화면 상태를 재현하기 위한 구조적 단위”로 이해되고 있습니다.  
이런 구조를 상정하면, 무한 스크롤은 단순한 로딩 패턴이 아니라  
시간에 따라 변하는 피드의 문맥을 보존하는 체계로 바라볼 수 있습니다.

---

## 4. 불러오지 않은 구간으로의 점프 문제

무한 스크롤에서는 **아직 로드되지 않은 영역으로의 스크롤 점프**가 흔히 발생합니다.  
스크롤바를 빠르게 내리거나 페이지 끝으로 이동하는 경우  
그 위치의 데이터는 아직 존재하지 않으므로 scrollTop의 의미가 달라집니다.  

이 문제를 이해할 때마다  
“스크롤의 거리값이 실제 데이터 상의 어떤 구간을 의미하는가”라는 질문이 남습니다.  
이 질문은 거리 개념을 **픽셀 단위가 아닌 데이터·커서·시간 축의 상대 좌표**로 확장해서 볼 필요가 있습니다.

---

## 5. 점프 거리 기반 접근 (거리 → 데이터 위치 매핑)

한 번의 스크롤 이동이 매우 길 때,  
시스템이 그 거리에 해당하는 데이터를 전부 가지고 있지 않은 경우가 많습니다.  
그래서 스크롤 이동량을 정규화하고, 그 크기에 따라 **데이터 위치를 추정하는 방식**을 생각해보았습니다.

### 거리의 정규화

화면 높이를 기준으로 정규화된 거리값을 정의합니다.  
`jumpVh = |targetScrollTop - currentScrollTop| / viewportHeight`  
이 값은 사용자가 “화면 몇 개 분량을 건너뛰려 하는가”를 나타냅니다.  

예를 들어  
- `jumpVh = 0.5` → 절반 화면 정도의 이동  
- `jumpVh = 2` → 두세 페이지 분량의 점프  
- `jumpVh = 8` → 멀리 떨어진 위치로의 이동  

이 비율을 기준으로 로딩 전략을 구분할 수 있습니다.

### 거리 구간별 전략

| 구간 | 특징 | 처리 방식 |
|------|------|-----------|
| 근거리(≤L1) | 안전영역 내 이동 | 현재 앵커를 기준으로 인덱스 이동 |
| 중거리(L1~L2) | 연속 로딩 가능 범위 | 이동량을 상한으로 제한 |
| 원거리(>L2) | 하드 점프 | 비율 또는 도메인 축 기반의 상대 위치 추정 |

- 근거리 이동은 누적 높이를 활용하여  
  앵커 인덱스에 deltaIndex를 더하는 식으로 처리됩니다.  
- 중거리 이동은 이동량을 일정 범위로 제한해  
  시스템이 처리 가능한 안전 구간 안에서만 확장합니다.  
- 원거리 이동은 픽셀 기반 추정 대신  
  데이터 비율(ratio) 또는 도메인 축(예: timestamp)을 활용하여  
  대략적인 위치를 추정합니다.  
  전체 데이터 수를 N, 스크롤 비율을 r이라 하면  
  대략 `targetIndex ≒ N × r` 정도로 해석할 수 있습니다.

### 도메인 축 기반 점프의 관찰

시간이나 ID 같은 도메인 단위의 축을 이용하면  
사용자에게 이동의 맥락이 더 명확하게 전달됩니다.  
예를 들어 “2024년 3월 게시물로 이동”이라는 표현은  
단순히 500px 아래로 이동하는 것보다 의미가 분명해집니다.  
이 접근은 사용자가 “지금 어느 위치에 와 있는가”를  
더 직관적으로 느끼게 하는 효과가 있습니다.

### 거리 기반 접근의 정리

이 접근은 **물리적 거리와 논리적 데이터 위치를 동적으로 연결해보는 시도**입니다.  
모든 점프를 정밀하게 재현할 수는 없지만,  
거리의 크기에 따라 데이터를 해석하는 방식이 달라질 수 있다는 점에서  
로딩 효율과 연속성을 함께 고려할 수 있습니다.  

결국 스크롤 정합을 “픽셀 단위의 정밀도”가 아니라  
“맥락 단위의 자연스러움”으로 이해하는 방향이라 생각합니다.

---

## 6. UX 관점에서의 체감 품질과 안정화 기법

무한 스크롤의 정합을 완벽히 맞추는 것은 여전히 어렵습니다.  
그러나 사용자가 느끼는 ‘자연스러움’은 기술적 정확도보다  
**연속성, 예측 가능성, 시각적 안정감**에 의해 좌우된다고 생각합니다.  
그 관점에서 저는 안전영역(safe window)과 프리로딩(preloading)을  
UX 품질을 안정화하는 핵심 도구로 보고 있습니다.

### 6.1 안전영역(safe window)

안전영역은 현재 뷰포트 주변에 미리 확보해 두는 로드 범위를 의미합니다.  
사용자가 화면을 빠르게 움직이더라도,  
이 영역 안에서는 즉각적인 렌더링이 가능하도록 데이터를 유지합니다.  

- 위쪽 안전영역은 빠른 스크롤 복귀 시 로딩 지연을 막아줍니다.  
- 아래쪽 안전영역은 다음 구간 로딩이 완료될 때까지의 여유를 제공합니다.  
- 영역의 폭이 지나치게 넓으면 메모리·연산 비용이 커지므로  
  화면 높이 비율 기반으로 동적으로 조정하는 접근이 필요합니다.  

실제 환경에서는 네트워크 지연, 사용자 스크롤 속도,  
디바이스 성능을 기준으로 안전영역 크기를 점진적으로 조정하는 방식이  
가장 체감 품질을 높이는 결과로 이어지는 듯합니다.

### 6.2 프리로딩(preloading)

프리로딩은 사용자의 시야에 들어오기 전에  
다음 콘텐츠를 미리 요청하거나 렌더링하는 접근입니다.  
이미지, 영상, 광고처럼 로딩 비용이 큰 요소일수록 효과가 뚜렷합니다.  

- **근거리 프리로딩**: 바로 다음 페이지의 데이터를 미리 가져옵니다.  
- **맥락 기반 프리로딩**: 스크롤 방향·속도·패턴을 기반으로 필요한 구간만 예측적으로 로드합니다.  
- **우선순위 조정**: 네트워크 자원이 제한된 경우,  
  현재 뷰포트 인접 콘텐츠를 우선 처리합니다.  

프리로딩은 시각적 부드러움을 유지하는 데 직접적인 영향을 미칩니다.  
완전한 정합을 구현하지 않더라도  
“항상 준비된 화면”처럼 보이게 하는 경험적 안정감을 제공합니다.

### 6.3 시각적 완충 장치들

- **로딩 플레이스홀더**를 사용하여 높이 변화를 미리 확보하면  
  새 데이터가 들어올 때의 점프감을 줄일 수 있습니다.  
- **스켈레톤 UI**는 실제 콘텐츠가 들어오기 전의 일시적 시각 안정성을 제공합니다.  
- **하드 점프 구간**은 일시적으로 “로딩 중 블록”으로 표현하고,  
  실제 데이터가 준비되면 자연스럽게 교체합니다.  
- **에러 구간**은 조용히 숨기지 않고,  
  “재시도 안내 블록”이나 회색 영역 등으로 시각적 피드백을 주는 것이 바람직합니다.  

이런 시각적 완충 장치들은  
정확한 정합을 대신해 사용자에게 “지속적인 흐름 안에 있다”는 인식을 만들어 줍니다.

### 6.4 정리

안전영역과 프리로딩은 정합 문제를 완전히 해결하지는 못하지만,  
사용자가 불연속성을 체감하기 전에 대응할 수 있는 완충 구조로 작동합니다.  
결국 UX 품질의 핵심은 완벽한 수치적 일치보다  
**끊김 없는 탐색의 감각을 유지하는 것**에 있다는 점을 다시 확인하게 됩니다.

---

## 7. 데이터 정합과 체감 UX의 균형점

무한 스크롤의 설계는 수학적 정확도와 사용자의 체감 사이에서 균형을 찾는 일로 보입니다.  
서버 커서의 정합, 스냅샷 구조, 안전영역 제어를 통해 **정확성의 최소 기준**을 확보하고,  
그 위에 **자연스러운 이동감**을 더하는 방향이 현실적으로 느껴집니다.  

정합을 절대적 목표로 삼기보다,  
예상 가능한 오차 안에서 일관된 시스템을 유지하는 쪽이 실제 환경에서는 더 유효한 접근으로 보입니다.

---

## 8. 정합을 다루는 사고 방식

무한 스크롤의 정합은 단순히 픽셀을 맞추는 기술적 문제가 아닙니다.  
데이터, 커서, 높이, 거리 간의 관계를 **동적으로 조정하는 구조적 문제**로 이해됩니다.  

그래서 설계자는 **픽셀의 정밀도보다 흐름의 일관성**을 우선 고려하게 됩니다.  
사용자가 인식하는 것은 절대 좌표가 아니라,  
“끊김 없는 맥락의 지속성”이기 때문입니다.

---

## 9. 그럼에도 불구하고 해결되지 않는 영역들

모든 시도에도 불구하고 완전한 정합은 여전히 달성하기 어렵습니다.  
이 한계를 인식하는 것이 오히려 자연스러운 일로 느껴집니다.

### 9.1 비동기 데이터의 불확정성
- 서버 데이터가 실시간으로 변하면 계산된 높이와 커서의 의미가 달라집니다.  
- 동일 시점의 데이터라도 지연이나 재정렬로 순서가 바뀔 수 있습니다.  

### 9.2 클라이언트 추정치의 오차
- 이미지 로딩이나 반응형 레이아웃 변화로  
  예상 높이와 실제 높이 사이에 차이가 누적됩니다.  

### 9.3 중간 구간의 파손
- 하드 점프 후 빠른 복귀 시 중간 구간이 비어 앵커를 잃는 경우가 있습니다.  
- 이미 내려받은 데이터가 삭제되면 누적 높이 계산이 깨집니다.  

### 9.4 사용자 조작의 예외
- 트랙패드 가속 등 빠른 스크롤은 로딩 속도를 넘어섭니다.  
- 브라우저의 scroll restoration 동작이 환경별로 달라 완전한 일관성을 기대하기 어렵습니다.  

### 9.5 UX적 한계
- 사용자는 ±10% 정도의 위치 차이를 거의 인식하지 못합니다.  
- 정합을 과도하게 높이려는 시도는 복잡도에 비해 체감 효용이 크지 않습니다.  

---

## 결론

무한 스크롤의 정합은 수치적 일관성을 추구하는 과정이라기보다,  
사용자에게 “끊김 없는 흐름”을 제공하기 위한 지속적인 조정의 과정으로 느껴집니다.  
이 글은 그 과정을 정리한 개인적인 아이데이션이며,  
향후 더 구체적인 구현과 실험을 통해 이 생각을 다듬어볼 예정입니다.
